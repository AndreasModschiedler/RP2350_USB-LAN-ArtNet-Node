/**
 * @file dmx.c
 * @brief DMX-512 output driver for RP2350 using UART1
 *
 * Uses UART1 (GPIO4/GPIO5) with the RS485 direction pins to transmit
 * DMX-512 frames.  The BREAK and MAB are generated by briefly asserting the
 * UART break condition via the hardware register.
 *
 * A double-buffer scheme prevents tearing: one buffer is transmitted while
 * the other is written by the ArtNet callback.
 *
 * Note: rdm.c also uses UART1 for RDM packets.  The two modules are
 * mutually exclusive by design: dmx_task() checks a shared bus-busy flag
 * set by rdm.c before transmitting.
 */

#include "dmx.h"
#include "pins.h"
#include "config.h"

#include "pico/stdlib.h"
#include "hardware/uart.h"
#include "hardware/gpio.h"
#include "hardware/timer.h"

#include <string.h>

/* ── UART configuration ──────────────────────────────────────────────────── */
#define DMX_UART        uart1

/* ── Shared bus-busy flag (set by rdm.c while an RDM transaction runs) ────── */
extern volatile bool g_rdm_bus_busy;

/* ── Double-buffer ───────────────────────────────────────────────────────── */
static dmx_frame_buffer_t s_buf[2];
static volatile uint8_t   s_write_idx = 0u;
static volatile uint8_t   s_read_idx  = 1u;

/* ── Transmission state ──────────────────────────────────────────────────── */
static volatile bool  s_running    = false;
static          uint8_t s_rate_hz  = DMX_TARGET_HZ;
static volatile uint32_t s_last_tx_us = 0u;

/* ── Initialisation ──────────────────────────────────────────────────────── */

void dmx_init(void) {
    /* Initialise RS485 direction pins */
    gpio_init(PIN_DMX_DE);
    gpio_set_dir(PIN_DMX_DE, GPIO_OUT);
    gpio_init(PIN_DMX_RE);
    gpio_set_dir(PIN_DMX_RE, GPIO_OUT);
    DMX_RS485_DIR_RX();

    /* Initialise UART1 for 250 kbps, 8N2 */
    uart_init(DMX_UART, DMX_BAUD_RATE);
    gpio_set_function(PIN_DMX_TX, GPIO_FUNC_UART);
    gpio_set_function(PIN_DMX_RX, GPIO_FUNC_UART);
    uart_set_hw_flow(DMX_UART, false, false);
    uart_set_format(DMX_UART, 8, 2, UART_PARITY_NONE);

    /* Initialise both frame buffers to all-zeros (blackout) */
    memset(&s_buf[0], 0, sizeof(s_buf[0]));
    memset(&s_buf[1], 0, sizeof(s_buf[1]));
    s_buf[0].channel_count = DMX_CHANNELS;
    s_buf[1].channel_count = DMX_CHANNELS;
}

/* ── Buffer update ───────────────────────────────────────────────────────── */

void dmx_update(const uint8_t *data, uint16_t count) {
    if (count > DMX_CHANNELS) count = DMX_CHANNELS;

    dmx_frame_buffer_t *buf = &s_buf[s_write_idx];
    buf->data[0] = 0x00u; /* DMX null start code */
    memcpy(&buf->data[1], data, count);
    if (count < DMX_CHANNELS) {
        memset(&buf->data[1 + count], 0, DMX_CHANNELS - count);
    }
    buf->channel_count = count;

    /* Atomic double-buffer swap */
    uint8_t old_write = s_write_idx;
    s_write_idx = s_read_idx;
    s_read_idx  = old_write;
}

/* ── Single frame transmission (blocking) ───────────────────────────────── */

static void transmit_frame(void) {
    if (g_rdm_bus_busy) return; /* yield to RDM transaction */

    const dmx_frame_buffer_t *buf = &s_buf[s_read_idx];
    uint16_t len = 1u + buf->channel_count;

    DMX_RS485_DIR_TX();

    /* BREAK: hold TX low for > 88 µs */
    uart_set_break(DMX_UART, true);
    busy_wait_us_32(DMX_BREAK_US);
    uart_set_break(DMX_UART, false);

    /* MAB: TX returns high automatically after clearing break; wait MAB */
    busy_wait_us_32(DMX_MAB_US);

    /* Transmit frame */
    uart_write_blocking(DMX_UART, buf->data, len);
    uart_tx_wait_blocking(DMX_UART);

    DMX_RS485_DIR_RX();
}

/* ── Control ─────────────────────────────────────────────────────────────── */

void dmx_start(void) {
    s_running = true;
    s_last_tx_us = time_us_32();
}

void dmx_stop(void) {
    s_running = false;
    DMX_RS485_DIR_RX();
}

void dmx_set_rate(uint8_t hz) {
    if (hz < 1u)  hz = 1u;
    if (hz > 44u) hz = 44u;
    s_rate_hz = hz;
}

/* ── Main-loop task ──────────────────────────────────────────────────────── */

void dmx_task(void) {
    if (!s_running) return;

    uint32_t now_us   = time_us_32();
    uint32_t interval = 1000000u / s_rate_hz;

    if ((now_us - s_last_tx_us) >= interval) {
        s_last_tx_us = now_us;
        transmit_frame();
    }
}
